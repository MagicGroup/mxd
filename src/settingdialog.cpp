/***************************************************************************
 *   Copyright (C) 2005 by yunfan                                          *
 *   yunfan_zg@163.com                                                     *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "settingdialog.h"
#include <list>
#include <qregexp.h>
#include <qstringlist.h>
#include <qfile.h>
#include <qtextstream.h>
#include <qlineedit.h>
#include <qcombobox.h>
#include <qframe.h>
#include <qcheckbox.h>
#include <qradiobutton.h>
#include <qdir.h>
#include <kpushbutton.h>
#include <kmessagebox.h>
#include <kprocess.h>
#include <ktabwidget.h>
#include <kconfig.h>
#include <kdesktopfile.h>
#include <kapplication.h>
#include <klocale.h>

#define ETH                     "ETH"
#define USER                    "USER"
#define DEMAND                  "DEMAND"
#define DNSTYPE                 "DNSTYPE"
#define PEERDNS                 "PEERDNS"
#define DNS1                    "DNS1"
#define DNS2                    "DNS2"
#define DEFAULTROUTE            "DEFAULTROUTE"
#define CONNECT_TIMEOUT         "CONNECT_TIMEOUT"
#define CONNECT_POLL            "CONNECT_POLL"
#define ACNAME                  "ACNAME"
#define SERVICENAME             "SERVICENAME"
#define PING                    "FORCEPING"
#define CF_BASE                 "CF_BASE"
#define PIDFILE                 "PIDFILE"
#define SYNCHRONOUS             "SYNCHRONOUS"
#define CLAMPMSS                "CLAMPMSS"
#define LCP_INTERVAL            "LCP_INTERVAL"
#define LCP_FAILURE             "LCP_FAILURE"
#define PPPOE_TIMEOUT           "PPPOE_TIMEOUT"
#define FIREWALL                "FIREWALL"
#define LINUX_PLUGIN            "LINUX_PLUGIN"
#define PPPOE_EXTRA             "PPPOE_EXTRA"
#define PPPD_EXTRA              "PPPD_EXTRA"

#define YES                     "yes"
#define NO                      "no"

#define DNS_SERVER              "SERVER"
#define DNS_SPECIFY             "SPECIFY"
#define DNS_NOCHANGE            "NOCHANGE"

#define FIREWALL_NONE           "NONE"
#define FIREWALL_STANDALONE     "STANDALONE"
#define FIREWALL_MASQUERADE     "MASQUERADE"

#define CONF_COMMENT_START      "# pppoe.conf\n# generated by Magic xDSL Dialer"
#define SECRET_COMMENT_START    "# pap-secrets/chap-secrets\n# updated by Magic xDSL Dialer"

#define CONF_COMMENT_ADVANCE    "### ONLY TOUCH THE FOLLOWING SETTINGS IF YOU'RE AN EXPERT"
#define SECRET_COMMENT_TIP      "# Secrets for authentication using PAP\n# client\tserver\tsecret\t\t\tIP addresses"

#define EQUALS                  "="

#define PPPOE_CONF_FILE         "pppoe.conf"
#define PAP_SECRETS_FILE        "pap-secrets"
#define CHAP_SECRETS_FILE       "chap-secrets"

#define IFCONFIG                "/sbin/ifconfig"
#define CONF_DIR                "/etc/ppp"

enum DnsType { DT_SERVER, DT_SPECIFY, DT_NOCHANGE};
enum FireWallType { FW_None, FW_StandAlone, FW_Masquerade};

typedef struct userItem {
	QString client;
	QString server;
	QString password;
	QString ip;
} userItem;

class PPPoEConfFile {
public:
	PPPoEConfFile() {  loadDefaultConf(); };
	PPPoEConfFile(QString &dir) { loadConfFrom(dir); }

	QString eth;
	QString user;
	QString password; // used in /etc/ppp/pap-secrets
	QString demand;
	DnsType dnsType;
	bool freeDns;
	QString dns1;
	QString dns2;
	bool defaultRoute;
	
	/// advance settings
	int connectTimeout;  // in secs
	int connectPoll;    // in secs
	QString acName;
	QString serviceName;
	QString ping;
	QString cfBase;
	QString pidFile;
	bool synchronous;
	QString clampMSS;
	
	int lcpInterval;
	int lcpFailure;
	int pppoeTimeout;
	
	FireWallType firewall;
	QString linuxPlugin;
	QString pppoeExtra;
	QString pppdExtra;

	bool isOk;
	void loadDefaultConf();
	bool loadConfFrom(QString dir);
	bool saveConfTo(QString dir);

	bool loadSecret(const QString dir);
	bool saveSecret(const QString secretFile);
};

void PPPoEConfFile::loadDefaultConf()
{
	eth = "eth0";
	user = "";
	password = ""; // used in /etc/ppp/pap-secrets
	demand = "no";
	dnsType = DT_SERVER;
	freeDns = true; // "yes" "no"
	dns1 = "";
	dns2 = "";
	defaultRoute = true;

	/// advance settings
	connectTimeout = 30;  // in secs
	connectPoll = 2;    // in secs
	acName = "";
	serviceName = "";
	ping = ".";
	cfBase = "`basename $CONFIG`";
	pidFile = "\"/var/run/$CF_BASE-pppoe.pid\"";
	synchronous = true; // "yes" or "no"
	clampMSS = "1412"; // can be "no"

	lcpInterval = 20;
	lcpFailure = 3;
	pppoeTimeout = 80;

	firewall = FW_None;
	linuxPlugin = "";
	pppoeExtra = "";
	pppdExtra = "";
}

bool PPPoEConfFile::loadConfFrom(QString dir)
{
	loadDefaultConf();

	QFile file(dir + "/" + PPPOE_CONF_FILE);
	if(!file.open(IO_ReadOnly)){
		printf("load conf file error: %s\n", (dir + "/" + PPPOE_CONF_FILE).ascii());
		return false;
	}
	
	QString line;
	QStringList lineList;
	QTextStream stream(&file);
	while(!stream.atEnd()){
		line = stream.readLine().stripWhiteSpace();
		if(line.startsWith("#")) continue;
		lineList = QStringList::split(EQUALS, line);
		if(lineList.size() != 2)
			continue;
		
		lineList[0].stripWhiteSpace();
		lineList[1].stripWhiteSpace();
		
		if(lineList[0] ==  ETH){
			eth = lineList[1];
		} else if(lineList[0] ==  USER){
				user = lineList[1];
			} else if(lineList[0] ==  DEMAND){
					demand = lineList[1];
				} else if(lineList[0] ==  DNSTYPE){
						if(lineList[1] == DNS_SERVER)
							dnsType = DT_SERVER;
						else if(lineList[1] == DNS_SPECIFY)
							dnsType = DT_SPECIFY;
						else if(lineList[1] == DNS_NOCHANGE)
							dnsType = DT_NOCHANGE;
						else continue;
					} else if(lineList[0] ==  PEERDNS){
							if(lineList[1] == YES)
								freeDns = true;
							else if(lineList[1] == NO)
								freeDns = false;
							else 
								continue;
						} else if(lineList[0] ==  DNS1){
								dns1 = lineList[1];
							} else if(lineList[0] ==  DNS2){
									dns2 = lineList[1];
								} else if(lineList[0] ==  DEFAULTROUTE){
										if(lineList[1] == YES)
											defaultRoute = true;
										else if(lineList[1] == NO)
											defaultRoute = false;
										else 
											continue;
									} else if(lineList[0] ==  CONNECT_TIMEOUT){
											bool ok;
											int num = lineList[1].toInt(&ok);
											if(!ok) continue;
											connectTimeout = num;
										}

		else if(lineList[0] ==  CONNECT_POLL){
				bool ok;
				int num = lineList[1].toInt(&ok);
				if(!ok) continue;
				connectPoll = num;
			} else if(lineList[0] ==  ACNAME){
					acName = lineList[1];
				} else if(lineList[0] ==  SERVICENAME){
						serviceName = lineList[1];
					} else if(lineList[0] ==  PING){
							ping = lineList[1].mid(1, lineList[1].length()-2 );
						} else if(lineList[0] ==  CF_BASE){
								cfBase = lineList[1];
							} else if(lineList[0] ==  PIDFILE){
									pidFile = lineList[1];
								} else if(lineList[0] ==  SYNCHRONOUS){
										if(lineList[1] == YES)
											synchronous = true;
										else if(lineList[1] == NO)
											synchronous = false;
										else 
											continue;
									}

		else if(lineList[0] ==  CLAMPMSS){
			clampMSS = lineList[1]; // could be a number or "no"
		} else if(lineList[0] ==  LCP_INTERVAL){
				bool ok;
				int num = lineList[1].toInt(&ok);
				if(!ok) continue;
				lcpInterval = num;
			} else if(lineList[0] ==  LCP_FAILURE){
					bool ok;
					int num = lineList[1].toInt(&ok);
					if(!ok) continue;
					lcpFailure = num;
				} else if(lineList[0] ==  PPPOE_TIMEOUT){
						bool ok;
						int num = lineList[1].toInt(&ok);
						if(!ok) continue;
						pppoeTimeout = num;
					} else if(lineList[0] ==  FIREWALL){
							if(lineList[1] == FIREWALL_NONE)
								firewall = FW_None;
							else if(lineList[1] == FIREWALL_STANDALONE)
								firewall = FW_StandAlone;
							else if(lineList[1] == FIREWALL_MASQUERADE)
								firewall = FW_Masquerade;
							else continue;
						} else if(lineList[0] ==  LINUX_PLUGIN){
								linuxPlugin = lineList[1];
							} else if(lineList[0] ==  PPPOE_EXTRA){
									pppoeExtra = lineList[1].mid(1, lineList[1].length() -2 );
								} else if(lineList[0] ==  PPPD_EXTRA){
										pppdExtra = lineList[1].mid(1, lineList[1].length() -2 );
									}
	}
	file.close();
	loadSecret(dir + "/" + PAP_SECRETS_FILE);
	return true;
}

bool PPPoEConfFile::saveConfTo(QString dir)
{
	// at first, we append username/password to pap-secrets
	if(!saveSecret(dir + "/" + PAP_SECRETS_FILE)) return false;
	if(!saveSecret(dir + "/" + CHAP_SECRETS_FILE)) return false;

	QFile file(dir + "/" + PPPOE_CONF_FILE);
	if(file.exists()) file.remove();
	if(!file.open(IO_WriteOnly )){
		printf("error on writing conf file: %s\n", (dir + "/" + PPPOE_CONF_FILE).ascii());
		return false;
	}
	
	QTextStream stream(&file);
	
	stream<< CONF_COMMENT_START << "\n" << endl;

	stream<< ETH             << EQUALS << eth << endl;
	stream<< USER            << EQUALS << user << endl;
	stream<< DEMAND          << EQUALS << demand << endl;

	QString tmp;
	switch(dnsType){
	case DT_SERVER:
		tmp = DNS_SERVER; break;
	case DT_SPECIFY:
		tmp = DNS_SPECIFY; break;
	case DT_NOCHANGE:
		tmp = DNS_NOCHANGE; break;
	default:
		tmp = DNS_SERVER;
	}
	
	stream<< DNSTYPE         << EQUALS << tmp << endl;
	stream<< PEERDNS         << EQUALS << (freeDns?YES:NO) << endl;
	stream<< DNS1            << EQUALS << dns1 << endl;
	stream<< DNS2            << EQUALS << dns2 << endl;
	stream<< DEFAULTROUTE    << EQUALS << (defaultRoute?YES:NO) << endl;

	stream<< endl;
	stream<< CONF_COMMENT_ADVANCE << "\n" << endl;
	//Q_UINT32 tmp = connectTimeout;
	stream<< CONNECT_TIMEOUT << EQUALS << connectTimeout << endl;
	//tmp = connectPoll;
	stream<< CONNECT_POLL    << EQUALS << connectPoll << endl;
	stream<< ACNAME          << EQUALS << acName << endl;
	stream<< SERVICENAME     << EQUALS << serviceName << endl;
	stream<< PING            << EQUALS << "\"" << ping << "\"" << endl;
	stream<< CF_BASE         << EQUALS << cfBase << endl;
	stream<< PIDFILE         << EQUALS << pidFile << endl;
	stream<< SYNCHRONOUS     << EQUALS << (synchronous?YES:NO) << endl;
	stream<< CLAMPMSS        << EQUALS << clampMSS << endl;
	
	stream<< LCP_INTERVAL    << EQUALS << lcpInterval << endl;
	stream<< LCP_FAILURE     << EQUALS << lcpFailure << endl;
	stream<< PPPOE_TIMEOUT   << EQUALS << pppoeTimeout << endl;

	switch(firewall){
	case FW_None:
		tmp = FIREWALL_NONE; break;
	case FW_StandAlone:
		tmp = FIREWALL_STANDALONE; break;
	case FW_Masquerade:
		tmp = FIREWALL_MASQUERADE; break;
	default:
		tmp = FIREWALL_NONE; 
	}
	stream<< FIREWALL        << EQUALS << tmp << endl;
	stream<< LINUX_PLUGIN    << EQUALS << linuxPlugin << endl;
	stream<< PPPOE_EXTRA     << EQUALS << "\"" << pppoeExtra << "\"" << endl;
	stream<< PPPD_EXTRA      << EQUALS << "\"" << pppdExtra << "\"" << endl;
	
	file.close();
	return true;
}

bool PPPoEConfFile::loadSecret(const QString secretFile)
{
	QFile papReader(secretFile);
	if(!papReader.open(IO_ReadOnly)){
		printf("Cannot open \"%s\" to read!\n", secretFile.ascii());
		return false;
	}
	QTextStream streamReader(&papReader);
	QString line;
	QStringList lineList;
	while(!streamReader.atEnd()){
		line = streamReader.readLine().stripWhiteSpace();
		if(line.startsWith("#")) continue;
		lineList = QStringList::split("\t", line);
		if(lineList.size() < 4)
			continue;
		userItem item;
		item.client = lineList[0];
		item.server = lineList[1];
		item.password = lineList[2];
		item.ip = lineList[3];
		if(item.client == user){
			password = item.password;
		}
	}
	papReader.close();
	return true;
}

bool PPPoEConfFile::saveSecret(const QString secretFile)
{
	if(user.isEmpty()) return true;
	std::list<userItem> userList;

	QFile papReader(secretFile);
	if(!papReader.open(IO_ReadOnly)){
		printf("Cannot open \"%s\" to read!\n", secretFile.ascii());
		return false;
	}
	QTextStream streamReader(&papReader);
	QString line;
	QStringList lineList;
	bool isExisted = false;
	while(!streamReader.atEnd()){
		line = streamReader.readLine().stripWhiteSpace();
		if(line.startsWith("#")) continue;
		lineList = QStringList::split("\t", line);
		if(lineList.size() < 4)
			continue;
		userItem item;
		item.client = lineList[0];
		item.server = lineList[1];
		item.password = lineList[2];
		item.ip = lineList[3];
		if(item.client == user){
			item.password = password;
			isExisted = true;
		}
		userList.push_back(item);
	}
	papReader.close();

	if(!isExisted){
		userItem item;
		item.client = user;
		item.server = "*";
		item.password = password;
		item.ip = "*";
		userList.push_back(item);
	}

	QFile papWriter(secretFile);
	if(!papWriter.open(IO_WriteOnly)){
		printf("Cannot open \"%s\" to write!\n", secretFile.ascii());
		return false;
	}
	QTextStream streamWriter(&papWriter);
	streamWriter << SECRET_COMMENT_START << endl;
	streamWriter << SECRET_COMMENT_TIP << endl;
	std::list<userItem>::iterator iter;
	for(iter= userList.begin(); iter!=userList.end(); ++iter){
		streamWriter << iter->client << "\t" << iter->server<< "\t" << iter->password << "\t" << iter->ip << endl;
	}
	papWriter.close();
	return true;
}


/** Setting Dialog class */

SettingDialog::SettingDialog(QWidget* parent, const char* name, bool modal, WFlags fl)
	: MxDConfigureUIBase( parent, name, modal, fl ), m_IsConfigChanged(false),
	m_AutoStartSet(false), m_AutoStopOnExitSet(false)
{
	ktabMain->addTab(TabPage, i18n("Basic"));
	ktabMain->addTab(TabPage_2, i18n("Advance"));
	getEthernetCards();

	loadProgramConfig();

	PPPoEConfFile conf;
	conf.loadConfFrom(CONF_DIR);
	updateDialog(&conf);

	connect(kbtnDefault, SIGNAL(clicked()), SLOT(slotDefaultClick()));
	connect(kbtnSave, SIGNAL(clicked()), SLOT(slotSaveClick()));
	connect(kbtnCancel, SIGNAL(clicked()), SLOT(slotCancelClick()));

	connect(leUsername, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));
	connect(lePassword, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));
	connect(cbbEth, SIGNAL(activated(int)), SLOT(slotConfigureChanged()));
	connect(cbbDNS, SIGNAL(activated(int)), SLOT(slotDnsChanged(int)));
	connect(leDNS1, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));
	connect(leDNS2, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));

	connect(chbAutoStart, SIGNAL(clicked()), SLOT(slotConfigureChanged()));
	connect(chkbStopOnExit, SIGNAL(clicked()), SLOT(slotConfigureChanged()));

	// advance settings
	connect(rbtnSyn, SIGNAL(clicked()), SLOT(slotConfigureChanged()));
	connect(leServiceName, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));
	connect(leACName, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));
	connect(lePPPoEExtra, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));
	connect(lePPPDExtra, SIGNAL(textChanged(const QString &)), SLOT(slotConfigureChanged()));

	connect(rbtnFireWallNone, SIGNAL(clicked()), SLOT(slotConfigureChanged()));
	connect(rbtnFireWallStandAlone, SIGNAL(clicked()), SLOT(slotConfigureChanged()));
	connect(rbtnFireWallMasquerade, SIGNAL(clicked()), SLOT(slotConfigureChanged()));
}

SettingDialog::~SettingDialog()
{
}

void SettingDialog::slotDefaultClick()
{
	PPPoEConfFile conf;
	updateDialog(&conf);
	kbtnSave->setEnabled(true);
	kbtnCancel->setText( i18n( "&Cancel" ) );
}

void SettingDialog::slotSaveClick()
{
	PPPoEConfFile *conf = getConfValues();
	conf->saveConfTo(CONF_DIR);
	delete conf;
	saveProgramConfig();
	m_IsConfigChanged = false;
	kbtnSave->setEnabled(false);
	kbtnCancel->setText( i18n( "&Close" ) );
}

void SettingDialog::slotCancelClick()
{
	close();
}

void SettingDialog::closeEvent( QCloseEvent *e)
{
	if(m_IsConfigChanged && KMessageBox::questionYesNo(this, 
			i18n("Configure has been changed, closing dialog will\n"
				" lose all changes, are you sure?")) == KMessageBox::No){
		e->ignore();
	}else
		e->accept();
}

void SettingDialog::getEthernetCards()
{
	FILE* fp = fopen("/proc/net/dev", "r");

	QStringList list;

	if (!fp) return;
//		return list;
	char interface[8];
	char buffer[128];

	// Ignore header...
	fgets(buffer, sizeof(buffer), fp);
	fgets(buffer, sizeof(buffer), fp);
	while(fgets(buffer, sizeof(buffer), fp))
	{
		sscanf(buffer, " %[^ \t\r\n:]", interface);
		list.append(interface);
	}
	if(list.size())
		cbbEth->insertStringList(list);
	//return list;
	//m_EthCardQuery->start(KProcess::Block, KProcess::Stdout);
}

void SettingDialog::slotConfigureChanged()
{
	m_IsConfigChanged = true;
	kbtnSave->setEnabled(true);
	kbtnCancel->setText( i18n( "&Cancel" ) );
}

void SettingDialog::slotDnsChanged( int index)
{
	slotConfigureChanged();
	if(index == 1){
		fraDNS->setEnabled(true);
		leDNS1->setEnabled(true);
		leDNS2->setEnabled(true);
	} else {
		fraDNS->setEnabled(false);
	}
}

void SettingDialog::updateDialog( PPPoEConfFile * conf )
{
	if(!conf) return;

	leUsername->setText(conf->user);
	lePassword->setText(conf->password);
	cbbEth->setCurrentText(conf->eth);
	switch(conf->dnsType){
	case DT_SERVER:
		cbbDNS->setCurrentItem(0);
		fraDNS->setEnabled(false); break;
	case DT_SPECIFY:
		cbbDNS->setCurrentItem(1);
		fraDNS->setEnabled(true); break;
	case DT_NOCHANGE:
		cbbDNS->setCurrentItem(2);
		fraDNS->setEnabled(false); break;
	default:
		cbbDNS->setCurrentItem(0);
		fraDNS->setEnabled(false);
	}
	
	leDNS1->setText(conf->dns1);
	leDNS2->setText(conf->dns2);

	if(m_AutoStartSet) chbAutoStart->setChecked(true);
	if(m_AutoStopOnExitSet) chkbStopOnExit->setChecked(true);

	rbtnSyn->setChecked(conf->synchronous);
	leServiceName->setText(conf->serviceName);
	leACName->setText(conf->acName);
	lePPPoEExtra->setText(conf->pppoeExtra);
	lePPPDExtra->setText(conf->pppdExtra);

	switch(conf->firewall){
	case FW_None:
		rbtnFireWallNone->setChecked(true); break;
	case FW_StandAlone:
		rbtnFireWallStandAlone->setChecked(true); break;
	case FW_Masquerade:
		rbtnFireWallMasquerade->setChecked(true); break;
	default:
		rbtnFireWallNone->setChecked(true);
	}
	
}

PPPoEConfFile * SettingDialog::getConfValues( )
{
	PPPoEConfFile *conf = new PPPoEConfFile();
	conf->user = leUsername->text();
	conf->password = lePassword->text();
	conf->eth = cbbEth->currentText();
	switch(cbbDNS->currentItem()){
	case 0:
		conf->dnsType = DT_SERVER;
		break;
	case 1:
		conf->dnsType = DT_SPECIFY;
		break;
	case 2:
		conf->dnsType = DT_NOCHANGE;
		break;
	default:
		conf->dnsType = DT_SERVER;
	}
	conf->dns1 = leDNS1->text();
	conf->dns2 = leDNS2->text();
	
	conf->synchronous = rbtnSyn->isChecked();
	conf->serviceName = leServiceName->text();
	conf->acName = leACName->text();
	conf->pppoeExtra = lePPPoEExtra->text();
	conf->pppdExtra = lePPPDExtra->text();

	if(rbtnFireWallNone->isChecked())
		conf->firewall = FW_None;
	else if(rbtnFireWallStandAlone->isChecked())
			conf->firewall = FW_StandAlone;
		else if(rbtnFireWallMasquerade->isChecked())
				conf->firewall = FW_Masquerade;
			else
				conf->firewall = FW_None;
	return conf;
}

void SettingDialog::loadProgramConfig( )
{
	QString autoStartDir = QDir::homeDirPath() + "/.kde/Autostart";
	QString desktopFile = autoStartDir +  "/mxd.desktop";
	QFile file(desktopFile);
	if(file.exists()) m_AutoStartSet = true;

	KConfig* cfg = kapp->config();
	KConfigGroupSaver groupSaver(cfg, "General");
	m_AutoStopOnExitSet = cfg->readBoolEntry("StopOnExit", false);
}

void SettingDialog::saveProgramConfig( )
{
	QString autoStartDir = QDir::homeDirPath() + "/.kde/Autostart";
	QString desktopFile = autoStartDir +  "/00-mxd.desktop";
	QFile file(desktopFile);
	if(file.exists()) file.remove();
	if(chbAutoStart->isChecked()){
		KDesktopFile *autoStart = new KDesktopFile(desktopFile);
		autoStart->writeEntry("Encoding", "UTF-8");
		autoStart->writeEntry("Name", "Magic xDSL Dialer");
		autoStart->writeEntry("Exec", "mxd-restart");
		autoStart->writeEntry("Icon", "mxd");
		autoStart->writeEntry("Type", "Application");
		autoStart->writeEntry("X-KDE-autostart-phase", "2");
		autoStart->writeEntry("StartupNotify", "false");
		autoStart->writeEntry("Comment", "Magic xDSL Dialer. A convenient tool to handle "
					"\"Roaring Penguin PPPoE\".");
		autoStart->writeEntry("Comment\[zh_CN\]", i18n("Magic xDSL Dialer. A convenient tool to handle \"Roaring Penguin PPPoE\"."));
	
		delete autoStart;
	}

	KConfig* cfg = kapp->config();
	KConfigGroupSaver groupSaver(cfg, "General");
	cfg->writeEntry("StopOnExit", chkbStopOnExit->isChecked());
}

